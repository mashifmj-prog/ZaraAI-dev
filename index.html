<!-- ADD TO EXISTING CODE - Predictive Risk Assessment System -->
<script>
// ==================== PREDICTIVE RISK ASSESSMENT ENGINE ====================
class PredictiveRiskEngine {
    constructor() {
        this.riskPatterns = this.initializeRiskPatterns();
        this.userBehaviorHistory = [];
        this.riskScores = {
            current: 0,
            trends: [],
            predictions: []
        };
    }

    initializeRiskPatterns() {
        return {
            stressIndicators: {
                'rushed_decisions': { weight: 0.8, triggers: ['urgent', 'quick', 'immediately', 'asap'] },
                'multitasking': { weight: 0.7, triggers: ['busy', 'multiple', 'simultaneous', 'overwhelmed'] },
                'fatigue': { weight: 0.6, triggers: ['tired', 'exhausted', 'sleep', 'energy'] },
                'emotional_stress': { weight: 0.9, triggers: ['angry', 'frustrated', 'anxious', 'stressed'] }
            },
            securityHabits: {
                'password_reuse': { weight: 0.7, frequency: 0 },
                'click_happiness': { weight: 0.8, frequency: 0 },
                'oversharing': { weight: 0.5, frequency: 0 },
                'security_bypass': { weight: 0.9, frequency: 0 }
            },
            environmentalFactors: {
                'public_wifi_usage': { weight: 0.4 },
                'device_sharing': { weight: 0.6 },
                'travel_frequency': { weight: 0.3 }
            }
        };
    }

    analyzeUserBehavior(message, context) {
        const behaviorSnapshot = {
            timestamp: new Date().toISOString(),
            message: message,
            context: context,
            detectedRisks: this.detectRiskPatterns(message, context),
            stressLevel: this.assessStressLevel(message),
            securityAwareness: this.assessSecurityAwareness(context)
        };

        this.userBehaviorHistory.push(behaviorSnapshot);
        this.updateRiskScore(behaviorSnapshot);
        
        // Keep only last 100 entries for performance
        if (this.userBehaviorHistory.length > 100) {
            this.userBehaviorHistory.shift();
        }

        return this.generateRiskPrediction();
    }

    detectRiskPatterns(message, context) {
        const detectedRisks = [];
        const lowerMessage = message.toLowerCase();

        // Analyze stress indicators
        Object.entries(this.riskPatterns.stressIndicators).forEach(([pattern, data]) => {
            if (data.triggers.some(trigger => lowerMessage.includes(trigger))) {
                detectedRisks.push({
                    type: 'stress',
                    pattern: pattern,
                    weight: data.weight,
                    confidence: this.calculateConfidence(message, data.triggers)
                });
            }
        });

        // Analyze context-based risks
        if (context.includes('stress') && context.includes('security')) {
            detectedRisks.push({
                type: 'high_risk_context',
                pattern: 'stress_security_overlap',
                weight: 0.85,
                confidence: 0.9
            });
        }

        return detectedRisks;
    }

    assessStressLevel(message) {
        let stressScore = 0;
        const stressKeywords = {
            'high': ['overwhelmed', 'anxious', 'panic', 'crisis', 'emergency'],
            'medium': ['stressed', 'busy', 'pressure', 'deadline', 'urgent'],
            'low': ['tired', 'sleepy', 'concerned', 'worry']
        };

        const lowerMessage = message.toLowerCase();
        
        Object.entries(stressKeywords).forEach(([level, keywords]) => {
            const matches = keywords.filter(keyword => lowerMessage.includes(keyword)).length;
            if (level === 'high') stressScore += matches * 3;
            if (level === 'medium') stressScore += matches * 2;
            if (level === 'low') stressScore += matches * 1;
        });

        return Math.min(stressScore, 10); // Normalize to 0-10 scale
    }

    assessSecurityAwareness(context) {
        let awarenessScore = 5; // Base score
        
        if (context.includes('training') || context.includes('learning')) {
            awarenessScore += 2;
        }
        if (context.includes('phishing') || context.includes('security')) {
            awarenessScore += 1;
        }
        if (context.includes('stress') || context.includes('rushed')) {
            awarenessScore -= 2;
        }

        return Math.max(1, Math.min(awarenessScore, 10));
    }

    calculateConfidence(message, triggers) {
        const lowerMessage = message.toLowerCase();
        const matches = triggers.filter(trigger => lowerMessage.includes(trigger)).length;
        return Math.min(matches / triggers.length * 2, 1); // Normalize to 0-1
    }

    updateRiskScore(behaviorSnapshot) {
        let newScore = 5; // Base risk score

        // Adjust based on detected risks
        behaviorSnapshot.detectedRisks.forEach(risk => {
            newScore += risk.weight * risk.confidence * 2;
        });

        // Adjust based on stress level
        newScore += (behaviorSnapshot.stressLevel / 10) * 3;

        // Adjust based on security awareness (inverse)
        newScore += ((10 - behaviorSnapshot.securityAwareness) / 10) * 2;

        this.riskScores.current = Math.max(1, Math.min(newScore, 10));
        this.riskScores.trends.push({
            timestamp: behaviorSnapshot.timestamp,
            score: this.riskScores.current
        });

        // Keep only last 20 trends
        if (this.riskScores.trends.length > 20) {
            this.riskScores.trends.shift();
        }
    }

    generateRiskPrediction() {
        if (this.riskScores.trends.length < 3) {
            return {
                currentRisk: this.riskScores.current,
                prediction: 'insufficient_data',
                confidence: 0,
                recommendations: this.getGeneralRecommendations()
            };
        }

        const trend = this.calculateTrend();
        const prediction = this.predictFutureRisk(trend);
        
        return {
            currentRisk: this.riskScores.current,
            trend: trend,
            prediction: prediction.futureRisk,
            confidence: prediction.confidence,
            timeframe: 'next_24_hours',
            recommendations: this.getTargetedRecommendations(),
            alertLevel: this.getAlertLevel(this.riskScores.current)
        };
    }

    calculateTrend() {
        const recentScores = this.riskScores.trends.slice(-5);
        if (recentScores.length < 2) return 'stable';

        const firstScore = recentScores[0].score;
        const lastScore = recentScores[recentScores.length - 1].score;
        const difference = lastScore - firstScore;

        if (difference > 1.5) return 'increasing';
        if (difference < -1.5) return 'decreasing';
        return 'stable';
    }

    predictFutureRisk(trend) {
        let futureRisk = this.riskScores.current;
        let confidence = 0.7;

        switch (trend) {
            case 'increasing':
                futureRisk = Math.min(10, this.riskScores.current + 1.5);
                confidence = 0.8;
                break;
            case 'decreasing':
                futureRisk = Math.max(1, this.riskScores.current - 1);
                confidence = 0.6;
                break;
            default:
                futureRisk = this.riskScores.current;
                confidence = 0.7;
        }

        return { futureRisk, confidence };
    }

    getAlertLevel(riskScore) {
        if (riskScore >= 8) return 'high';
        if (riskScore >= 6) return 'medium';
        if (riskScore >= 4) return 'low';
        return 'minimal';
    }

    getGeneralRecommendations() {
        return [
            "Practice stress management techniques before handling sensitive information",
            "Take regular breaks during high-pressure periods",
            "Verify all urgent requests through secondary channels",
            "Enable multi-factor authentication on critical accounts"
        ];
    }

    getTargetedRecommendations() {
        const recommendations = [];
        const recentRisks = this.userBehaviorHistory.slice(-3);

        // Analyze recent behavior for targeted advice
        const highStressCount = recentRisks.filter(snapshot => snapshot.stressLevel >= 7).length;
        const securityMentions = recentRisks.filter(snapshot => 
            snapshot.context.includes('security') || snapshot.message.includes('phishing')
        ).length;

        if (highStressCount >= 2) {
            recommendations.push({
                priority: 'high',
                message: "🚨 High stress detected: Consider postponing critical security decisions until you're less stressed",
                action: "Take a 5-minute break and practice deep breathing"
            });
        }

        if (securityMentions === 0 && this.riskScores.current >= 6) {
            recommendations.push({
                priority: 'medium',
                message: "🔍 Low security awareness: Let's do a quick security refresh",
                action: "Ask me about current phishing threats or start a training exercise"
            });
        }

        if (this.riskScores.current >= 8) {
            recommendations.push({
                priority: 'critical',
                message: "⚡ Critical risk level: Immediate action recommended",
                action: "Review recent emails carefully, avoid clicking links, and verify suspicious communications"
            });
        }

        // Add general recommendations if no specific ones triggered
        if (recommendations.length === 0) {
            recommendations.push({
                priority: 'low',
                message: "✅ Good security posture maintained",
                action: "Continue current practices and stay vigilant"
            });
        }

        return recommendations;
    }

    getRiskDashboard() {
        const trend = this.calculateTrend();
        const prediction = this.generateRiskPrediction();

        return {
            currentScore: this.riskScores.current,
            trend: trend,
            trendArrow: this.getTrendArrow(trend),
            prediction: prediction,
            behaviorHistory: this.userBehaviorHistory.length,
            averageStress: this.calculateAverageStress(),
            riskLevel: this.getAlertLevel(this.riskScores.current)
        };
    }

    getTrendArrow(trend) {
        switch (trend) {
            case 'increasing': return '📈';
            case 'decreasing': return '📉';
            default: return '➡️';
        }
    }

    calculateAverageStress() {
        if (this.userBehaviorHistory.length === 0) return 0;
        const totalStress = this.userBehaviorHistory.reduce((sum, snapshot) => sum + snapshot.stressLevel, 0);
        return (totalStress / this.userBehaviorHistory.length).toFixed(1);
    }
}

// ==================== ENHANCE INTELLIGENCE CORE WITH PREDICTIVE ENGINE ====================
class EnhancedIntelligenceCore {
    constructor() {
        this.currentMode = 'security';
        this.conversationHistory = [];
        this.knowledgeBase = this.initializeKnowledge();
        this.phishingSimulator = new PhishingSimulator();
        this.riskEngine = new PredictiveRiskEngine();
        this.teamManager = new TeamManager();
    }

    // ENHANCE processMessage method with risk assessment
    processMessage(message) {
        this.conversationHistory.push({ role: 'user', content: message });
        const lowerMsg = message.toLowerCase();
        
        // Get risk assessment before generating response
        const riskAssessment = this.riskEngine.analyzeUserBehavior(message, this.detectLifeContext(lowerMsg));
        
        // Handle training commands
        if (lowerMsg.includes('phishing training') || lowerMsg.includes('phishing exercise')) {
            return this.startPhishingTraining();
        }

        // Handle risk dashboard requests
        if (lowerMsg.includes('risk') && lowerMsg.includes('dashboard')) {
            return this.showRiskDashboard(riskAssessment);
        }
        
        // Detect life context and determine response approach
        const context = this.detectLifeContext(lowerMsg);
        const securityRisk = this.assessSecurityRisk(context);
        
        return this.generateEnhancedResponse(message, context, securityRisk, riskAssessment);
    }

    generateEnhancedResponse(originalMessage, contexts, securityRisk, riskAssessment) {
        let response = { type: 'security', tags: [] };
        
        // Add risk context to response
        response.riskAssessment = riskAssessment;

        // Training context
        if (contexts.includes('training')) {
            response.type = 'training';
            response.tags.push('training');
            response.response = this.generateTrainingResponse(originalMessage);
        }
        // High risk context - prioritize risk mitigation
        else if (riskAssessment.currentRisk >= 7) {
            response.type = 'risk_alert';
            response.tags.push('security', 'risk');
            response.response = this.generateRiskAwareResponse(contexts, riskAssessment, originalMessage);
        }
        // High stress context - lead with wellness
        else if (contexts.includes('stress') && securityRisk > 0.6) {
            response.type = 'wellness';
            response.tags.push('wellness');
            response.response = this.generateStressAwareResponse(contexts, securityRisk, originalMessage);
        }
        // Life event context - bridge to security
        else if (contexts.some(ctx => ['renovations', 'workPressure', 'familyStress'].includes(ctx))) {
            response.type = 'life';
            response.tags.push('life');
            response.response = this.generateLifeAwareResponse(contexts, originalMessage);
        }
        // Pure security context
        else if (contexts.includes('security')) {
            response.type = 'security';
            response.tags.push('security');
            response.response = this.generateSecurityResponse(originalMessage);
        }
        // General context
        else {
            response.type = 'security';
            response.tags.push('security');
            response.response = this.generateGeneralResponse(originalMessage);
        }
        
        return response;
    }

    generateRiskAwareResponse(contexts, riskAssessment, message) {
        const highestRecommendation = riskAssessment.recommendations[0];
        
        let response = `🚨 <strong>Risk Alert - Level ${riskAssessment.alertLevel.toUpperCase()}</strong>\n\n`;
        response += `I'm detecting elevated security risk factors in our conversation.\n\n`;
        response += `📊 <strong>Current Risk Score:</strong> ${riskAssessment.currentRisk}/10\n`;
        response += `📈 <strong>Trend:</strong> ${riskAssessment.trend}\n\n`;
        
        if (highestRecommendation) {
            response += `💡 <strong>Priority Recommendation:</strong> ${highestRecommendation.message}\n`;
            response += `🛠️ <strong>Action:</strong> ${highestRecommendation.action}\n\n`;
        }
        
        response += `Would you like to:\n`;
        response += `• Discuss specific risk factors I'm detecting\n`;
        response += `• Practice stress-reduction techniques\n`;
        response += `• Review security best practices\n`;
        response += `• See your full risk dashboard`;
        
        return response;
    }

    showRiskDashboard(riskAssessment) {
        const dashboard = this.riskEngine.getRiskDashboard();
        
        let response = `📊 <strong>Security Risk Dashboard</strong>\n\n`;
        response += `🛡️ <strong>Current Risk Level:</strong> ${dashboard.riskLevel.toUpperCase()}\n`;
        response += `📈 <strong>Risk Score:</strong> ${dashboard.currentScore}/10 ${dashboard.trendArrow}\n`;
        response += `🔍 <strong>Trend:</strong> ${dashboard.trend}\n`;
        response += `😴 <strong>Average Stress:</strong> ${dashboard.averageStress}/10\n`;
        response += `📝 <strong>Behavior Analysis:</strong> ${dashboard.behaviorHistory} interactions analyzed\n\n`;
        
        response += `🎯 <strong>Predictions:</strong>\n`;
        response += `• 24-hour forecast: ${dashboard.prediction.prediction.toFixed(1)}/10 risk\n`;
        response += `• Confidence: ${Math.round(dashboard.prediction.confidence * 100)}%\n\n`;
        
        response += `💡 <strong>Recommendations:</strong>\n`;
        riskAssessment.recommendations.forEach((rec, index) => {
            response += `${index + 1}. ${rec.message}\n`;
        });
        
        return {
            type: 'risk_dashboard',
            response: response,
            tags: ['security', 'analytics']
        };
    }

    // ... rest of your existing IntelligenceCore methods remain the same
    // (detectLifeContext, assessSecurityRisk, generateTrainingResponse, etc.)
}

// ==================== TEAM MANAGER (First part of team features) ====================
class TeamManager {
    constructor() {
        this.teamMembers = new Map();
        this.teamScores = {
            overall: 0,
            phishing: 0,
            awareness: 0,
            engagement: 0
        };
    }

    addTeamMember(userId, userData) {
        this.teamMembers.set(userId, {
            ...userData,
            joinDate: new Date().toISOString(),
            riskScore: 5,
            trainingCompleted: 0,
            lastActive: new Date().toISOString()
        });
        this.updateTeamScores();
    }

    updateTeamScores() {
        // Simplified team scoring - will be enhanced
        const members = Array.from(this.teamMembers.values());
        if (members.length === 0) return;

        this.teamScores = {
            overall: Math.round(members.reduce((sum, m) => sum + (10 - m.riskScore), 0) / members.length),
            phishing: Math.round(members.reduce((sum, m) => sum + m.trainingCompleted, 0) / members.length * 10),
            awareness: 65, // Placeholder - will be calculated from behavior
            engagement: Math.round((members.filter(m => 
                new Date() - new Date(m.lastActive) < 7 * 24 * 60 * 60 * 1000
            ).length / members.length) * 100)
        };
    }

    getTeamDashboard() {
        return {
            memberCount: this.teamMembers.size,
            scores: this.teamScores,
            recentActivity: this.getRecentActivity(),
            riskDistribution: this.getRiskDistribution()
        };
    }

    getRecentActivity() {
        // Simplified - will be enhanced
        return Array.from(this.teamMembers.values())
            .sort((a, b) => new Date(b.lastActive) - new Date(a.lastActive))
            .slice(0, 5)
            .map(member => ({
                name: member.name || 'Team Member',
                activity: 'Completed training',
                time: 'Recently'
            }));
    }

    getRiskDistribution() {
        const members = Array.from(this.teamMembers.values());
        return {
            low: members.filter(m => m.riskScore <= 3).length,
            medium: members.filter(m => m.riskScore > 3 && m.riskScore <= 6).length,
            high: members.filter(m => m.riskScore > 6).length
        };
    }
}

// ==================== UPDATE CHAT MANAGER ====================
class EnhancedChatManager {
    constructor() {
        this.intelligenceCore = new EnhancedIntelligenceCore();
        this.progressTracker = new ProgressTracker();
        this.setupEventListeners();
        
        // Initialize with demo team member for testing
        this.initializeDemoData();
    }

    initializeDemoData() {
        // Add demo team member to show team features
        this.intelligenceCore.teamManager.addTeamMember('demo-user', {
            name: 'You',
            riskScore: 5,
            trainingCompleted: 2
        });
    }

    // ... your existing setupEventListeners, processUserInput, etc. remain the same
    // Just make sure to use this.intelligenceCore instead of the old one
}
</script>
